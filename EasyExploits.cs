using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using System.IO;
using System.IO.Pipes;
using System.Net;
using Microsoft.Win32;
using System.Windows.Forms;
using System.Threading.Tasks;

namespace broski2._5
{
    // For some reason I decided to integrate EasyExploits API into Acenoid... (and modify it)
    class EasyExploits
    {

        internal class DLLInjection
        {
            public enum DllInjectionResult
            {
                DllNotFound,
                GameProcessNotFound,
                InjectionFailed,
                Success
            }

            public sealed class DllInjector
            {
                private static readonly IntPtr INTPTR_ZERO;

                private static DllInjector _instance;

                public static DllInjector GetInstance
                {
                    get
                    {
                        if (_instance == null)
                        {
                            _instance = new DllInjector();
                        }
                        return _instance;
                    }
                }

                static DllInjector()
                {
                    INTPTR_ZERO = (IntPtr)0;
                }

                private DllInjector()
                {
                }

                private bool bInject(uint pToBeInjected, string sDllPath)
                {
                    IntPtr intPtr = OpenProcess(1082u, 1, pToBeInjected);
                    if (intPtr == INTPTR_ZERO)
                    {
                        return false;
                    }
                    IntPtr procAddress = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                    if (procAddress == INTPTR_ZERO)
                    {
                        return false;
                    }
                    IntPtr intPtr2 = VirtualAllocEx(intPtr, (IntPtr)0, (IntPtr)sDllPath.Length, 12288u, 64u);
                    if (intPtr2 == INTPTR_ZERO)
                    {
                        return false;
                    }
                    byte[] bytes = Encoding.ASCII.GetBytes(sDllPath);
                    if (WriteProcessMemory(intPtr, intPtr2, bytes, (uint)bytes.Length, 0) == 0)
                    {
                        return false;
                    }
                    if (CreateRemoteThread(intPtr, (IntPtr)0, INTPTR_ZERO, procAddress, intPtr2, 0u, (IntPtr)0) == INTPTR_ZERO)
                    {
                        return false;
                    }
                    CloseHandle(intPtr);
                    return true;
                }

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern int CloseHandle(IntPtr hObject);

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttribute, IntPtr dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern IntPtr GetModuleHandle(string lpModuleName);

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);

                public DllInjectionResult Inject(string sProcName, string sDllPath)
                {
                    if (!File.Exists(sDllPath))
                    {
                        return DllInjectionResult.DllNotFound;
                    }
                    uint num = 0u;
                    Process[] processes = Process.GetProcesses();
                    for (int i = 0; i < processes.Length; i++)
                    {
                        if (!(processes[i].ProcessName != sProcName))
                        {
                            num = (uint)processes[i].Id;
                            break;
                        }
                    }
                    if (num == 0)
                    {
                        return DllInjectionResult.GameProcessNotFound;
                    }
                    if (!bInject(num, sDllPath))
                    {
                        return DllInjectionResult.InjectionFailed;
                    }
                    return DllInjectionResult.Success;
                }

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern IntPtr OpenProcess(uint dwDesiredAccess, int bInheritHandle, uint dwProcessId);

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, IntPtr dwSize, uint flAllocationType, uint flProtect);

                [DllImport("kernel32.dll", SetLastError = true)]
                private static extern int WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] buffer, uint size, int lpNumberOfBytesWritten);
            }
        }

        public class Module
        {
            private WebClient wc = new WebClient();

            private bool CheckLastestDll(RegistryKey registryKey)
            {
                string[] array = wc.DownloadString("https://raw.githubusercontent.com/GreenMs02/Update/master/Module.txt").Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                if (array[2] == "true")
                {
                    if (Directory.Exists(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData) + "\\Roblox\\Versions\\" + array[3]))
                    {
                        registryKey.SetValue("Ver", array[3]);
                        return true;
                    }
                    return false;
                }
                return false;
            }

            private bool CheckDllUpdate()
            {
                string[] array = wc.DownloadString("https://raw.githubusercontent.com/GreenMs02/Update/master/Module.txt").Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\\\CoCO", writable: true);
                if (registryKey == null)
                {
                    registryKey = Registry.CurrentUser.CreateSubKey("SOFTWARE\\\\CoCO");
                    registryKey.SetValue("Ver", "0");
                }
                else
                {
                    if (registryKey.GetValue("Ver").ToString() != array[0])
                    {
                        registryKey.SetValue("Ver", array[0]);
                        return true;
                    }
                    if (registryKey.GetValue("Ver").ToString() != array[3] && CheckLastestDll(registryKey))
                    {
                        return true;
                    }
                }
                return !File.Exists("EasyExploitsDLL.dll");
            }

            private bool DownloadDLL()
            {
                RegistryKey registryKey = Registry.CurrentUser.OpenSubKey("SOFTWARE\\\\CoCO", writable: true);
                string[] array = wc.DownloadString("https://raw.githubusercontent.com/GreenMs02/Update/master/Module.txt").Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
                if (registryKey.GetValue("Ver").ToString() == array[3] && CheckLastestDll(registryKey))
                {
                    wc.DownloadFile(array[4], "EasyExploitsDLL.dll");
                }
                else
                {
                    wc.DownloadFile(array[1], "EasyExploitsDLL.dll");
                }
                return File.Exists("EasyExploitsDLL.dll");
            }

            public void ExecuteScript(string Script)
            {
                if (namedPipeExist("ocybedam"))
                {
                    using(NamedPipeClientStream namedPipeClientStream = new NamedPipeClientStream(".", "ocybedam", PipeDirection.Out))
                    {
                        namedPipeClientStream.Connect();
                        using (StreamWriter streamWriter = new StreamWriter(namedPipeClientStream, Encoding.Default, 999999))
                        {
                            streamWriter.Write(Script);
                            streamWriter.Dispose();
                        }
                        namedPipeClientStream.Dispose();
                    }
                }
                else if (File.Exists("EasyExploitsDLL.dll"))
                {
                    MessageBox.Show("Please inject!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
                else
                {
                    MessageBox.Show("Turn off your antivirus before using Acenoid.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }

            private void InjectDLL()
            {
                switch(DLLInjection.DllInjector.GetInstance.Inject("RobloxPlayerBeta", Application.StartupPath + "\\EasyExploitsDLL.dll"))
                {
                    case DLLInjection.DllInjectionResult.DllNotFound:
                        MessageBox.Show("Couldn't find the exploit library!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        break;
                    case DLLInjection.DllInjectionResult.GameProcessNotFound:
                        MessageBox.Show("No ROBLOX process found!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        break;
                    case DLLInjection.DllInjectionResult.InjectionFailed:
                        MessageBox.Show("Injection failed! Please try again later.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        break;
                }
                while(!namedPipeExist("ocybedam"))
                    Task.Delay(25);
                if(namedPipeExist("ocybedam"))
                {
                    string InjectionCompleteScript = wc.DownloadString("https://pastebin.com/raw/yEuCk15u");
                    ExecuteScript(InjectionCompleteScript);
                }
            }

            public void LaunchExploit()
            {
                if (namedPipeExist("ocybedam"))
                {
                    ExecuteScript(wc.DownloadString("https://pastebin.com/raw/2sL9ygh6"));
                    MessageBox.Show("Already injected!", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
                else if (!CheckDllUpdate() && File.Exists("EasyExploitsDLL.dll"))
                {
                    InjectDLL();
                }
                else if (DownloadDLL())
                {
                    InjectDLL();
                }
                else
                {
                    MessageBox.Show("Cannot download the latest version!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }

            public static bool namedPipeExist(string pipeName)
            {
                try
                {
                    if (!WaitNamedPipe(Path.GetFullPath($"\\\\.\\pipe\\{pipeName}"), 0))
                    {
                        switch (Marshal.GetLastWin32Error())
                        {
                            case 0:
                                return false;
                            case 2:
                                return false;
                        }
                    }
                    return true;
                }
                catch (Exception)
                {
                    return false;
                }
            }

            [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
            private static extern bool WaitNamedPipe(string name, int timeout);
        }

    }
} // EasyExploits API by The EasyXploits team
